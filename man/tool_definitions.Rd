% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tool.R
\name{tool_definitions}
\alias{tool_definitions}
\alias{as_tool}
\alias{tool}
\alias{schema}
\title{Tool Definitions}
\usage{
as_tool(fn)

tool(name, description, ...)

schema(name, description, ..., strict = TRUE, additional_properties = FALSE)
}
\arguments{
\item{fn}{A function with annotations in its body comments using \verb{#'} prefix.
Supported tags:
\itemize{
\item \verb{@description}: Function description
\item \verb{@param name:type* description}: Parameter specification
}

Supported types: \code{string}, \code{integer}, \code{number}, \code{boolean}, \code{date},
\code{date-time}, and arrays using \verb{[type]} syntax (e.g., \verb{[integer]}).

The \code{*} suffix marks a parameter as required. If a parameter has a
default value in the function signature and no \code{*} suffix, it is
optional. If it has a \code{*} suffix, it overrides the default and becomes
required.}

\item{name}{Character. The tool or schema name}

\item{description}{Character. What the tool does or what the schema represents}

\item{...}{Named parameter specifications. See Details.}

\item{strict}{Logical. For \code{schema()} only. Whether to use strict mode (defaults to TRUE).
Added at root level of the schema definition.}

\item{additional_properties}{Logical. For \code{schema()} only. Whether to allow additional
properties in the schema (defaults to FALSE). Added to \code{args_schema}.}
}
\value{
For \code{tool()}: A list with:
\itemize{
\item \code{name}: Tool name (character)
\item \code{description}: Tool description (character)
\item \code{args_schema}: JSON Schema object with \code{type}, \code{properties}, and \code{required} fields
}

For \code{schema()}: Same as \code{tool()} but with additional fields:
\itemize{
\item \code{strict}: Logical (at root level)
\item \code{args_schema$additionalProperties}: Logical (inside args_schema)
}
}
\description{
Functions for defining tools and schemas using either annotations or direct specification.
\subsection{Annotation-based approach}{

\code{as_tool()} parses annotations from a function and converts it to a generic
tool definition with an \code{args_schema} field. This standardized format can be
converted to provider-specific formats internally.

Annotations use roxygen2-style \verb{#'} comments inside the function body (not
outside like regular roxygen2 documentation). The annotation syntax follows
plumber2 conventions for type specifications.

The package automatically enables source preservation when loaded. If you
defined functions before loading the package, simply redefine them after
loading argent.
}

\subsection{Direct specification approach}{

\code{tool()} creates a tool definition by directly specifying parameters, as an
alternative to using function annotations with \code{as_tool()}. This approach
is useful for complex nested structures or when defining tools without
corresponding R functions.

\code{schema()} is similar to \code{tool()} but designed for structured output schemas.
It includes additional fields (\code{strict} and \code{additionalProperties}) required
by some LLM providers for structured outputs.

Parameters are specified as named arguments. Each parameter value can be:
\itemize{
\item A string: \code{"type[*] [description]"} (e.g., \code{"string* The user's name"})
\item A list: For nested objects with \code{type} field and nested properties
}
}
}
\details{
\subsection{Type Specifications (for \code{tool()})}{

\strong{Primitive types:} \code{string}, \code{integer}, \code{number}, \code{boolean}, \code{date},
\code{date-time}

\strong{Arrays:} Use \verb{[type]} syntax (e.g., \code{"[string]"}, \code{"[integer]"})

\strong{Required marker:} Add \code{*} after type (e.g., \code{"string*"})

\strong{Descriptions:} Add text after type (e.g., \code{"string* The user's name"})

\strong{Nested objects:} Use list with \code{type = "object"} or \code{type = "object*"}:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{address = list(
  type = "object*",
  description = "Mailing address",
  street = "string* Street address",
  city = "string* City name"
)
}\if{html}{\out{</div>}}

\strong{Arrays of objects:} Use \code{type = "[object]"}:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{users = list(
  type = "[object]*",
  description = "List of users",
  name = "string*",
  email = "string*"
)
}\if{html}{\out{</div>}}
}
}
\examples{
\dontrun{
# Annotation-based approach
options(keep.source = TRUE)

my_fn <- function(x, y = 3L) {
    #' @description Add two numbers
    #' @param x:number* First number
    #' @param y:integer Second number (optional, has default)
    x + y
}

as_tool(my_fn)

# Direct specification - tool()
search_tool <- tool(
  name = "search_db",
  description = "Search the database",
  query = "string* Search query",
  limit = "integer Maximum results to return"
)

# Direct specification - schema()
output_schema <- schema(
  name = "flight_search",
  description = "Flight search results",
  destination = "string* Destination city",
  departure_date = "string* Departure date",
  passengers = "integer* Number of passengers",
  strict = TRUE,
  additional_properties = FALSE
)

# Nested object
create_user_tool <- tool(
  name = "create_user",
  description = "Create a new user",
  name = "string* User's full name",
  address = list(
    type = "object*",
    description = "User's mailing address",
    street = "string* Street address",
    city = "string* City name",
    zip = "string Postal code"
  )
)
}
}
